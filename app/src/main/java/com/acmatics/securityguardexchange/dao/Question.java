package com.acmatics.securityguardexchange.dao;

import java.util.List;
import com.acmatics.securityguardexchange.dao.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table "QUESTION".
 */
public class Question {

    private Long questionId;
    private String textKey;
    private String descriptionKey;
    private Long questionTypeId;
    private Long questionLevelId;
    private Boolean imageFlag;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient QuestionDao myDao;

    private QuestionType questionType;
    private Long questionType__resolvedKey;

    private QuestionLevel questionLevel;
    private Long questionLevel__resolvedKey;

    private List<AnswerChoice> answerChoices;

    public Question() {
    }

    public Question(Long questionId) {
        this.questionId = questionId;
    }

    public Question(Long questionId, String textKey, String descriptionKey, Long questionTypeId, Long questionLevelId, Boolean imageFlag) {
        this.questionId = questionId;
        this.textKey = textKey;
        this.descriptionKey = descriptionKey;
        this.questionTypeId = questionTypeId;
        this.questionLevelId = questionLevelId;
        this.imageFlag = imageFlag;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getQuestionDao() : null;
    }

    public Long getQuestionId() {
        return questionId;
    }

    public void setQuestionId(Long questionId) {
        this.questionId = questionId;
    }

    public String getTextKey() {
        return textKey;
    }

    public void setTextKey(String textKey) {
        this.textKey = textKey;
    }

    public String getDescriptionKey() {
        return descriptionKey;
    }

    public void setDescriptionKey(String descriptionKey) {
        this.descriptionKey = descriptionKey;
    }

    public Long getQuestionTypeId() {
        return questionTypeId;
    }

    public void setQuestionTypeId(Long questionTypeId) {
        this.questionTypeId = questionTypeId;
    }

    public Long getQuestionLevelId() {
        return questionLevelId;
    }

    public void setQuestionLevelId(Long questionLevelId) {
        this.questionLevelId = questionLevelId;
    }

    public Boolean getImageFlag() {
        return imageFlag;
    }

    public void setImageFlag(Boolean imageFlag) {
        this.imageFlag = imageFlag;
    }

    /** To-one relationship, resolved on first access. */
    public QuestionType getQuestionType() {
        Long __key = this.questionTypeId;
        if (questionType__resolvedKey == null || !questionType__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            QuestionTypeDao targetDao = daoSession.getQuestionTypeDao();
            QuestionType questionTypeNew = targetDao.load(__key);
            synchronized (this) {
                questionType = questionTypeNew;
            	questionType__resolvedKey = __key;
            }
        }
        return questionType;
    }

    public void setQuestionType(QuestionType questionType) {
        synchronized (this) {
            this.questionType = questionType;
            questionTypeId = questionType == null ? null : questionType.getQuestionTypeId();
            questionType__resolvedKey = questionTypeId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public QuestionLevel getQuestionLevel() {
        Long __key = this.questionLevelId;
        if (questionLevel__resolvedKey == null || !questionLevel__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            QuestionLevelDao targetDao = daoSession.getQuestionLevelDao();
            QuestionLevel questionLevelNew = targetDao.load(__key);
            synchronized (this) {
                questionLevel = questionLevelNew;
            	questionLevel__resolvedKey = __key;
            }
        }
        return questionLevel;
    }

    public void setQuestionLevel(QuestionLevel questionLevel) {
        synchronized (this) {
            this.questionLevel = questionLevel;
            questionLevelId = questionLevel == null ? null : questionLevel.getQuestionLevelId();
            questionLevel__resolvedKey = questionLevelId;
        }
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<AnswerChoice> getAnswerChoices() {
        if (answerChoices == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            AnswerChoiceDao targetDao = daoSession.getAnswerChoiceDao();
            List<AnswerChoice> answerChoicesNew = targetDao._queryQuestion_AnswerChoices(questionId);
            synchronized (this) {
                if(answerChoices == null) {
                    answerChoices = answerChoicesNew;
                }
            }
        }
        return answerChoices;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetAnswerChoices() {
        answerChoices = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}
